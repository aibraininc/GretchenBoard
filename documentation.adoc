= Gretchen Board Flashing Documentation
Doc Writer <kubisch@informatik.hu-berlin.de>
v0.1, 2019-03-28
:imagesdir: ./images
:toc:

_This is the Gretchen board flashing manual.
Following these steps will enable you to create an ISP and flash the boards for Gretchen._

[cols="a,a"]
|====
| image::before_assembly.png[Gretchen head] | image::after_assembly.png[Gretchen head]
|====



=== Recommended Tools
You will need these tools to flash the Gretchen Board.

Should have picture

* Breadboard
* Arduino Nano
* Arduino USB cable
* Capacitor 220uF 16V
* Cables
* Sensoriboards to flash

== Step 0. Setting up Serial Devices
For setting up your USB-to-Serial/RS485 device to best work with sensorimotors you have to *enable low latency mode* on your machine. Low latency mode is needed to have the best performance on higher baudrates and with multiple motors attached to the bus. Otherwise some machines tend to buffer data packages and send them delayed which is *NOT* recommended when using sensorimotors, because the library needs a tight real-time loop here. In order to temporarily set your interface to low-latency mode type:

=== Step 0.1 Install setserial
	sudo apt install setserial

=== Step 0.2 Create a udev rule file
	sudo nano /etc/udev/rules.d/50-ttyusb.rules

and put in

  KERNEL=="ttyUSB[0-9]*", MODE="0666", RUN+="/bin/setserial /dev/%k low_latency"
  KERNEL=="ttyACM[0-9]*", MODE="0666", RUN+="/bin/setserial /dev/%k low_latency"

The udev rules get activated when your reconnect your USB-to-serial device.


== Step 1. Check USB ISP board
[cols="a,a"]
|====
| *Image* |
| image::usbisp-1.jpg[320,240] | image::usbisp-2.jpg[320,240]
|====

You can select the voltage of VCC. There are 5v and 3.3v. We use 5v.



== Step 2. Set up the ISP hardware

=== Step 2.1 Use cables to connect ISP board with sensoriboard
[cols="a,a,a"]
|====
| *Arduino* | *Sensoriboard* | *Description*
| image::usbisp-3.png[320,240] | image::ispsensori.jpg[320,240] |
* Arduino SCK to Sensoriboard SCK
* ISP MISO to Sensoriboard MISO
* ISP MOSI to Sensoriboard MOSI
* ISP RST to Sensoriboard RESET
* ISP VCC to Sensoriboard 5V
* ISP GND to Sensoriboard GND
|====

It is photo that ISP connected with sensoriboard

[cols="a"]
|====
| *Image*
| image::usbisp-4.jpg[320,240]
|====


=== Step 2.2 Connect USB ISP to computer

== Step 3. Flash sensoriboard with ISP
=== Step 3.1 Download the library
  git clone https://github.com/aibraininc/sensoriboard-package.git

  git checkout v0.1

=== Step 3.2 Install XPCC

Install basic build system

  sudo apt-get install python python-jinja2 scons git

Install AVR toolchain

  sudo apt-get install gcc-avr binutils-avr avr-libc avrdude

Install ARM toolchain

  sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa
  sudo apt-get update
  sudo apt-get install gcc-arm-embedded openocd

Install packets

  sudo apt-get install gcc build-essential libboost-thread-dev \
                       libboost-system-dev libasio-dev

Install xpcc

  cd <path-to-sensoriboard-package>/sensorimotor/embedded
  git clone https://github.com/roboterclubaachen/xpcc.git

=== Step 3.3 Test with blinky. Sensoriboard should blink
  cd <path-to-sensoriboard-package>/sensorimotor/embedded/blinky
  make; make install;

Check if sensoriboard is blinking rapidly.

=== Step 3.4 Flash sensoriboard
  cd <path-to-sensoriboard-package>/sensorimotor/embedded/firmware
  scons program

== Step 4. Set motor ID
=== Step 4.1 Disconnect usb cable connecting ISP with computer
=== Step 4.2 Connect RS485 cable with computer and the sensoriboard
[cols="a"]
|====
| *Image*
| image::IMG_6006.jpg[320,240]
|====

=== Step 4.3 Run program to set ID
  cd <path-to-sensoriboard-package>/sensorimotor/embedded/tools
  ./set_id.py -p /dev/ttyUSB0 -b oldID -n newID
  ./set_id.py -p /dev/ttyUSB0 -b 127 -n 0
  *Default motor ID is 127.

=== Step 4.4 Test motor

  cd <path-to-sensoriboard-package>/libsensorimotor/py
  python example_pos_ctrl.py
  python example_imp_ctrl.py
  * For testing motor control, you should follow instruction on libsensorimotor repo.
  * Please build shared lib and set low_latency mode.
